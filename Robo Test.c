#pragma config(Sensor, in6,    ,               sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl10, button,         sensorTouch)
#pragma config(Sensor, dgtl11, limitSwitchDown, sensorTouch)
#pragma config(Sensor, dgtl12, limitSwitchUp,  sensorTouch)
#pragma config(Motor,  port1,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           armMotor,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port10,          rightMotor,    tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                          - Robo Dunk -                                             *|
|*                                    Gloria Ngan and CJ Zhang                                        *|
|*                                                                                                    *|
|*  This program uses the arm of the robot to automonously pick up a ball and move it to a "hoop".    *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]              [Name]              [Type]              [Description]                   *|
|*    Motor - Port 10         rightMotor          VEX Motor            Right motor                    *|
|*    Motor - Port 1          leftMotor           VEX Motor            Left motor                     *|
|*    Motor - Port 6          armMotor            VEX Motor            Arm motor                      *|
|*    Digital - Port 1,2 		  rightEncoder        VEX Shaft Encoder    Right side                     *|
|*    Digital - Port 3,4  		leftEncoder         VEX Shaft Encoder    Left side                      *|
\*----------------------------------------------------------------------------------------------------*/

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++

/*
Robot moves forward from starting line, does a 360 point turn to detect the pedestal. When the pedestal
is found, the robot stops turning to face it. The robot moves foward and once the claw is under the ball,
it raises the arm to secure it. The robot will retrace its steps to face the hoop. It will drive until it
is within range of the hoop and then drop the ball.
*/

int encoderCount;	//Global variable to record distance.

// Clear Encoders.
void clearEncoders()
{
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;
}

void stopRobot()
{
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	wait1Msec(1000);
}

//Lifts arm.
void moveArmUp()
{
	if(SensorValue[limitSwitchUp] < 1)
		motor[armMotor] = 20;	// x is the speed and direction (neg. or pos.) of the arm
	else
		motor[armMotor] = 0;
}

//Lowers arm.
void moveArmDown()
{
	if(SensorValue[limitSwitchDown] < 1)
		motor[armMotor] = -20;	// x is the speed and direction (neg. or pos.) of the arm
	else
		motor[armMotor] = 0;
}

void drive(int y)			// y is speed
{
	for(int i = 0; i <= y; i = i + 10)
	{
		motor[rightMotor] = i;
		motor[leftMotor]  = i;
		wait1Msec(200);
	}

	if(SensorValue[rightEncoder] > - SensorValue[leftEncoder])
	{
		motor[rightMotor] = y - 5;
		motor[leftMotor] = y;
	}

	if(SensorValue[rightEncoder] < - SensorValue[leftEncoder])
	{
		motor[rightMotor] = y;
		motor[leftMotor] = y - 5;
	}

	if(SensorValue[rightEncoder] == -SensorValue[leftEncoder])
	{
		motor[rightMotor] = y - 5;
		motor[leftMotor] = y;
	}

	for(int i = y; i >= 0; i = i - 10)
	{
		motor[rightMotor] = i;
		motor[leftMotor]  = i;
		wait1Msec(200);
	}
}

void fetchBall(int x){		// x is number of ticks
	clearEncoders();

	while(SensorValue[rightEncoder] < x)
		drive(40);
}

//Drives until an object within range is detected.
void senseDrive(int x)
{
	while(SensorValue[sonarSensor] > x || SensorValue[sonarSensor] == -1)	 	// Loop while robot's Ultrasonic sensor is further than x cm away from an object
	{                                    													  			 // || (or) it is '-1'.  (-1 is the value returned when nothing is in it's visable range)
		drive(40);
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

//Function to search for pedestal.
void scan(int x)
{
	clearEncoders();

	while(SensorValue[rightEncoder] < 250)
	{
		drive(40);
	}
	while(SensorValue[sonarSensor] > x || SensorValue[sonarSensor] == -1)
	{
			while(SensorValue[rightEncoder] < 1816)
			{
	 		// Turn function.
			motor[rightMotor] = 50;
			motor[leftMotor] = -50;
		}
	}
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	encoderCount = SensorValue[rightEncoder] * -1;
}

//Function to realign robot with hoop after scan finds the pedestal.
void retraceTurn()
{
	clearEncoders();
	while (SensorValue[rightEncoder] > encoderCount)
	{
		motor[rightMotor] = -60;
		motor[leftMotor] = 60;
	}
}

task main()
{
	while(1 == 1)
	{
		if(SensorValue[button] == 1)
		{
			clearEncoders();

			while(SensorValue[rightEncoder] < 250)
			{
				drive(40);
			}
			scan(20);
			fetchBall(58);
			moveArmUp();	//Picks up ball.
			stopRobot();
			retraceTurn();
			senseDrive(20);	//Forward until the goal is detected.
			moveArmDown();	//Drops ball.
		}
	}
}
