#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port10,          rightMotor,    tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                         - Basketball Drills -                                      *|
|*                                        Gloria Ngan and CJ Zhang                                    *|
|*                                                                                                    *|
|*                     This program instructs the robot to perform a basketball drill,                *|
|*                                transversing a set distance and back                                *|
|*                                                                                                    *|
|*                                         ROBOT CONFIGURATION                                        *|
|*                                                                                                    *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:          3+                                                                   *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor   - Port 10   rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor   - Port 1    leftMotor           VEX 3-wire module     Left side motor                   *|
|*    Digital - Port 1,2  rightEncoder        VEX Shaft Encoder     Right side                        *|
|*    Digital - Port 3,4  leftEncoder         VEX Shaft Encoder     Left side                         *|
\*----------------------------------------------------------------------------------------------------*/


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++


/*************************************************************************
Code is designed to allow the robot to move forward 20 inch initially
(640 ticks). Each 2 increments of the x parameter in the main method
increases the distance that the robot travels by 20 inches. This method
is designed to mimic or replicate how an actual vehicle is driven with
an acceleration, driving at constant velocity and then
braking/deceleration.
**************************************************************************/
void forward (int x, int y)
{
	// Clear Encoders
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

  //250 ticks
	//the acceleration (reduces probability of robot moving off from a straight line
	for(int i = 0; i <= y; i = i + 10)
  {
		motor[rightMotor] = i;		  // Motor on port10 is run forward
		motor[leftMotor]  = i;		  // Motor on port1 is run forward
		wait1Msec(200);	        		// Robot runs previous code for 100 milliseconds before moving on
	}

	//auto-correction code that programs the robot to move in straight line
	while (SensorValue[rightEncoder] < x)
		{
			if(SensorValue[rightEncoder] > - SensorValue[leftEncoder])
			{
				motor[rightMotor] = y - 5;
				motor[leftMotor] = y;
			}

			if(SensorValue[rightEncoder] < - SensorValue[leftEncoder])
			{
				motor[rightMotor] = y;
				motor[leftMotor] = y - 5;
			}

			if(SensorValue[rightEncoder] == - SensorValue[leftEncoder])
			{
				motor[rightMotor] = y - 5;
				motor[leftMotor] = y;
			}
		}

	//260 ticks
	for(int i = y; i >= 0; i = i - 10)
	{
		motor[rightMotor] = i;		  // Motor on port10 is run forward
		motor[leftMotor]  = i;		  // Motor on port1 is run forward
		wait1Msec(200);	        				// Robot runs previous code for 200 milliseconds before moving on
	}
}

//point turn 180
void turnP(int x)
{

	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	while (SensorValue[rightEncoder]< x)
	{
		motor[rightMotor] = 63;
		motor[leftMotor] = -63;
	}
}


task main()
{
			//forward(600 + (0 * 880), 60);
	  //	turnP(460);
	 	//	wait1Msec(1000);			// 1 Second delay

	 	//	forward(600 + (1 * 880), 60);
	  //	turnP(470);
	 	//	wait1Msec(1000);			// 1 Second delay

	 	//	forward(1480, 60);
	  //	turnP(470);
	 	//	wait1Msec(1000);			// 1 Second delay

	 	//	forward(600 + (3/2 * 880), 60);
	  //	turnP(470);
	 	//	wait1Msec(1000);			// 1 Second delay

	 	//	forward(600 + (2 * 880), 60);
	  //	turnP(470);
	 	//	wait1Msec(1000);			// 1 Second delay

	 	//	forward(600 + (5/2 * 880), 60);
	  //	turnP(470);
	 	//	wait1Msec(1000);			// 1 Second delay

	 	//	forward(600 + (6/2 * 880), 60);
	 	//	turnP(470);
	 	//	wait1Msec(1000);			// 1 Second delay

	 	//	forward(600 + (7/2 * 880), 60);
	 	//	turnP(470);
	 	//	wait1Msec(1000);			// 1 Second delay


	  for (int i = 0; i < 8; i++)
	  {
	  	forward(600 + (i/2 * 880), 60);
	  	turnP(450);

	 		wait1Msec(1000);			// 1 Second delay
		}
}
